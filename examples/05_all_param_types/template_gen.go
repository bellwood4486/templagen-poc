// Code generated by templagen; DO NOT EDIT.
package main

import (
	_ "embed"
	"fmt"
	"io"
	"text/template"
	"time"
)

//go:embed templates/all_types.tmpl
var all_typesTplSource string

var templates = map[string]*template.Template{
	"all_types": template.Must(template.New("all_types").Option("missingkey=error").Parse(all_typesTplSource)),
}

// Templates returns a map of all templates
func Templates() map[string]*template.Template {
	return templates
}

type All_typesItemsItem struct {
	ID int64
	Price float64
	Tags []string
	Title string
}

type All_typesRecordsItem struct {
	Age int
	Name string
	Score *int
}

type All_typesProduct struct {
	InStock bool
	Price float64
	SKU string
}

type All_typesUser struct {
	Email string
	ID int64
	Name string
}

// All_types represents parameters for all_types template
type All_types struct {
	Active bool
	Age int
	CategoryIDs []int
	Counters map[string]int
	CreatedAt time.Time
	Discount *float64
	Email *string
	Features map[string]bool
	Flags []bool
	Items []All_typesItemsItem
	Metadata map[string]string
	MiddleScore *int
	Name string
	OptionalItems *[]string
	PhoneNumber *string
	Price float64
	Prices map[string]float64
	Product All_typesProduct
	Ratings []float64
	Records []All_typesRecordsItem
	Score int64
	Tags []string
	User All_typesUser
}

// RenderAll_types renders the all_types template
func RenderAll_types(w io.Writer, p All_types) error {
	tmpl, ok := templates["all_types"]
	if !ok {
		return fmt.Errorf("template %q not found", "all_types")
	}
	return tmpl.Execute(w, p)
}

// Render renders a template by name with the given data
func Render(w io.Writer, name string, data any) error {
	tmpl, ok := templates[name]
	if !ok {
		return fmt.Errorf("template %q not found", name)
	}
	return tmpl.Execute(w, data)
}
