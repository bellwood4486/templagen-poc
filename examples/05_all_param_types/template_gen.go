// Code generated by templagen; DO NOT EDIT.
package main

import (
	_ "embed"
	"fmt"
	"io"
	"text/template"
	"time"
)

// TemplateName is a type-safe template name
type TemplateName string

const (
	TemplateNameBasic_types TemplateName = "basic_types"
	TemplateNameComplex_types TemplateName = "complex_types"
	TemplateNameMap_types TemplateName = "map_types"
	TemplateNamePointer_types TemplateName = "pointer_types"
	TemplateNameSlice_types TemplateName = "slice_types"
	TemplateNameStruct_types TemplateName = "struct_types"
)

//go:embed templates/basic_types.tmpl
var basic_typesTplSource string

//go:embed templates/complex_types.tmpl
var complex_typesTplSource string

//go:embed templates/map_types.tmpl
var map_typesTplSource string

//go:embed templates/pointer_types.tmpl
var pointer_typesTplSource string

//go:embed templates/slice_types.tmpl
var slice_typesTplSource string

//go:embed templates/struct_types.tmpl
var struct_typesTplSource string

var templates = map[TemplateName]*template.Template{
	TemplateNameBasic_types: template.Must(template.New("basic_types").Option("missingkey=error").Parse(basic_typesTplSource)),
	TemplateNameComplex_types: template.Must(template.New("complex_types").Option("missingkey=error").Parse(complex_typesTplSource)),
	TemplateNameMap_types: template.Must(template.New("map_types").Option("missingkey=error").Parse(map_typesTplSource)),
	TemplateNamePointer_types: template.Must(template.New("pointer_types").Option("missingkey=error").Parse(pointer_typesTplSource)),
	TemplateNameSlice_types: template.Must(template.New("slice_types").Option("missingkey=error").Parse(slice_typesTplSource)),
	TemplateNameStruct_types: template.Must(template.New("struct_types").Option("missingkey=error").Parse(struct_typesTplSource)),
}

// Templates returns a map of all templates
func Templates() map[TemplateName]*template.Template {
	return templates
}

// Render renders a template by name with the given data
func Render(w io.Writer, name TemplateName, data any) error {
	tmpl, ok := templates[name]
	if !ok {
		return fmt.Errorf("template %q not found", name)
	}
	return tmpl.Execute(w, data)
}

// ============================================================
// basic_types template
// ============================================================

// Basic_types represents parameters for basic_types template
type Basic_types struct {
	Active bool
	Age int
	CreatedAt time.Time
	Name string
	Price float64
	Score int64
}

// RenderBasic_types renders the basic_types template
func RenderBasic_types(w io.Writer, p Basic_types) error {
	tmpl, ok := templates[TemplateNameBasic_types]
	if !ok {
		return fmt.Errorf("template %q not found", TemplateNameBasic_types)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// complex_types template
// ============================================================

type Complex_typesItemsItem struct {
	ID int64
	Price float64
	Tags []string
	Title string
}

type Complex_typesRecordsItem struct {
	Age int
	Name string
	Score *int
}

// Complex_types represents parameters for complex_types template
type Complex_types struct {
	Items []Complex_typesItemsItem
	OptionalItems *[]string
	Records []Complex_typesRecordsItem
}

// RenderComplex_types renders the complex_types template
func RenderComplex_types(w io.Writer, p Complex_types) error {
	tmpl, ok := templates[TemplateNameComplex_types]
	if !ok {
		return fmt.Errorf("template %q not found", TemplateNameComplex_types)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// map_types template
// ============================================================

// Map_types represents parameters for map_types template
type Map_types struct {
	Counters map[string]int
	Features map[string]bool
	Metadata map[string]string
	Prices map[string]float64
}

// RenderMap_types renders the map_types template
func RenderMap_types(w io.Writer, p Map_types) error {
	tmpl, ok := templates[TemplateNameMap_types]
	if !ok {
		return fmt.Errorf("template %q not found", TemplateNameMap_types)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// pointer_types template
// ============================================================

// Pointer_types represents parameters for pointer_types template
type Pointer_types struct {
	Discount *float64
	Email *string
	MiddleScore *int
	PhoneNumber *string
}

// RenderPointer_types renders the pointer_types template
func RenderPointer_types(w io.Writer, p Pointer_types) error {
	tmpl, ok := templates[TemplateNamePointer_types]
	if !ok {
		return fmt.Errorf("template %q not found", TemplateNamePointer_types)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// slice_types template
// ============================================================

// Slice_types represents parameters for slice_types template
type Slice_types struct {
	CategoryIDs []int
	Flags []bool
	Ratings []float64
	Tags []string
}

// RenderSlice_types renders the slice_types template
func RenderSlice_types(w io.Writer, p Slice_types) error {
	tmpl, ok := templates[TemplateNameSlice_types]
	if !ok {
		return fmt.Errorf("template %q not found", TemplateNameSlice_types)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// struct_types template
// ============================================================

type Struct_typesProduct struct {
	InStock bool
	Price float64
	SKU string
}

type Struct_typesUser struct {
	Email string
	ID int64
	Name string
}

// Struct_types represents parameters for struct_types template
type Struct_types struct {
	Product Struct_typesProduct
	User Struct_typesUser
}

// RenderStruct_types renders the struct_types template
func RenderStruct_types(w io.Writer, p Struct_types) error {
	tmpl, ok := templates[TemplateNameStruct_types]
	if !ok {
		return fmt.Errorf("template %q not found", TemplateNameStruct_types)
	}
	return tmpl.Execute(w, p)
}

