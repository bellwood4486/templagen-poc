package gen

import (
	"fmt"
	"maps"
	"path/filepath"
	"slices"
	"strings"

	"github.com/bellwood4486/templagen-poc/internal/scan"
	"github.com/bellwood4486/templagen-poc/internal/typing"
	"github.com/bellwood4486/templagen-poc/internal/util"
)

// EmitMulti は複数のテンプレートから1つの統合Goファイルを生成する
// 単一テンプレートの場合も同じフォーマットで生成される
func EmitMulti(units []Unit) (string, error) {
	if len(units) == 0 {
		return "", fmt.Errorf("no units provided")
	}

	// 各テンプレートごとの処理結果を保持
	type templateData struct {
		name       string            // テンプレート名（例: "user", "user_list"）
		typeName   string            // 型名（例: "User", "UserList"）
		sourcePath string            // 埋め込むファイルパス
		varName    string            // embed変数名（例: "userTplSource"）
		typed      *typing.TypedSchema // 型情報
	}

	templates := make([]templateData, 0, len(units))
	allImports := make(map[string]struct{})

	// デフォルトのimport
	allImports["io"] = struct{}{}
	allImports["text/template"] = struct{}{}
	allImports["embed"] = struct{}{}
	allImports["fmt"] = struct{}{}

	// 各テンプレートを処理
	for _, unit := range units {
		// テンプレート名を抽出
		templateName := ExtractTemplateName(unit.SourcePath)
		typeName := util.Export(templateName)

		// テンプレートをスキャン
		sch, err := scan.ScanTemplate(unit.SourceLiteral)
		if err != nil {
			return "", fmt.Errorf("failed to scan template %s: %w", unit.SourcePath, err)
		}

		// 型解決
		typed, err := typing.Resolve(sch, unit.SourceLiteral)
		if err != nil {
			return "", fmt.Errorf("failed to resolve types for %s: %w", unit.SourcePath, err)
		}

		// 必要なimportを収集
		for _, imp := range typed.RequiredImports {
			allImports[imp] = struct{}{}
		}

		// テンプレートデータを追加
		templates = append(templates, templateData{
			name:       templateName,
			typeName:   typeName,
			sourcePath: unit.SourcePath,
			varName:    templateName + "TplSource",
			typed:      typed,
		})
	}

	// テンプレート名でソート（出力を安定させるため）
	slices.SortFunc(templates, func(a, b templateData) int {
		return strings.Compare(a.name, b.name)
	})

	// コード生成
	var b strings.Builder
	pkg := units[0].Pkg // すべて同じパッケージ名のはず

	// ヘッダー
	fmt.Fprintf(&b, "// Code generated by templagen; DO NOT EDIT.\n")
	fmt.Fprintf(&b, "package %s\n\n", pkg)

	// import セクション
	fmt.Fprintf(&b, "import (\n")
	keys := slices.Sorted(maps.Keys(allImports))
	for _, k := range keys {
		if k == "embed" {
			fmt.Fprintf(&b, "\t_ %q\n", k)
		} else {
			fmt.Fprintf(&b, "\t%q\n", k)
		}
	}
	fmt.Fprintf(&b, ")\n\n")

	// 各テンプレートのembed宣言
	for _, tmpl := range templates {
		fmt.Fprintf(&b, "//go:embed %s\n", tmpl.sourcePath)
		fmt.Fprintf(&b, "var %s string\n\n", tmpl.varName)
	}

	// Templates()マップ関数
	fmt.Fprintf(&b, "// Templates returns a map of all templates\n")
	fmt.Fprintf(&b, "func Templates() map[string]*template.Template {\n")
	fmt.Fprintf(&b, "\treturn map[string]*template.Template{\n")
	for _, tmpl := range templates {
		fmt.Fprintf(&b, "\t\t%q: template.Must(template.New(%q).Option(%q).Parse(%s)),\n",
			tmpl.name, tmpl.name, "missingkey=error", tmpl.varName)
	}
	fmt.Fprintf(&b, "\t}\n")
	fmt.Fprintf(&b, "}\n\n")

	// 各テンプレート用の名前付き型を生成
	generatedTypes := make(map[string]bool)
	for _, tmpl := range templates {
		// 名前付き型の生成
		for _, namedType := range tmpl.typed.NamedTypes {
			// 型名の衝突を避けるため、プレフィックスを付ける
			typeName := tmpl.typeName + namedType.Name
			if generatedTypes[typeName] {
				continue // すでに生成済み
			}
			generatedTypes[typeName] = true

			fmt.Fprintf(&b, "type %s struct {\n", typeName)
			// フィールドをソートして順序を安定化
			fieldNames := slices.Sorted(maps.Keys(namedType.Fields))
			for _, fieldName := range fieldNames {
				field := namedType.Fields[fieldName]
				// フィールドの型名も調整が必要な場合がある
				goType := adjustTypeForTemplate(field.GoType, tmpl.typeName)
				fmt.Fprintf(&b, "\t%s %s\n", field.Name, goType)
			}
			fmt.Fprintf(&b, "}\n\n")
		}

		// メインのパラメータ型を生成
		fmt.Fprintf(&b, "// %s represents parameters for %s template\n", tmpl.typeName, tmpl.name)
		fmt.Fprintf(&b, "type %s struct {\n", tmpl.typeName)
		// トップレベルフィールドをソートして順序を安定化
		topFieldNames := slices.Sorted(maps.Keys(tmpl.typed.Fields))
		for _, fieldName := range topFieldNames {
			field := tmpl.typed.Fields[fieldName]
			// フィールドの型名も調整が必要な場合がある
			goType := adjustTypeForTemplate(field.GoType, tmpl.typeName)
			fmt.Fprintf(&b, "\t%s %s\n", field.Name, goType)
		}
		fmt.Fprintf(&b, "}\n\n")
	}

	// 各テンプレート用のRender関数
	for _, tmpl := range templates {
		funcName := "Render" + tmpl.typeName
		fmt.Fprintf(&b, "// %s renders the %s template\n", funcName, tmpl.name)
		fmt.Fprintf(&b, "func %s(w io.Writer, p %s) error {\n", funcName, tmpl.typeName)
		fmt.Fprintf(&b, "\ttmpl, ok := Templates()[%q]\n", tmpl.name)
		fmt.Fprintf(&b, "\tif !ok {\n")
		fmt.Fprintf(&b, "\t\treturn fmt.Errorf(\"template %%q not found\", %q)\n", tmpl.name)
		fmt.Fprintf(&b, "\t}\n")
		fmt.Fprintf(&b, "\treturn tmpl.Execute(w, p)\n")
		fmt.Fprintf(&b, "}\n\n")
	}

	// 汎用Render関数
	fmt.Fprintf(&b, "// Render renders a template by name with the given data\n")
	fmt.Fprintf(&b, "func Render(w io.Writer, name string, data any) error {\n")
	fmt.Fprintf(&b, "\ttmpl, ok := Templates()[name]\n")
	fmt.Fprintf(&b, "\tif !ok {\n")
	fmt.Fprintf(&b, "\t\treturn fmt.Errorf(\"template %%q not found\", name)\n")
	fmt.Fprintf(&b, "\t}\n")
	fmt.Fprintf(&b, "\treturn tmpl.Execute(w, data)\n")
	fmt.Fprintf(&b, "}\n")

	return b.String(), nil
}

// ExtractTemplateName はファイルパスからテンプレート名を抽出する
// 例: "templates/user_list.tmpl" -> "user_list"
// 例: "email.tmpl" -> "email"
func ExtractTemplateName(path string) string {
	// ベース名を取得
	base := filepath.Base(path)

	// 拡張子を削除
	name := strings.TrimSuffix(base, filepath.Ext(base))

	// 数字プレフィックスを削除（例: "01_header" -> "header"）
	if len(name) > 3 && name[0] >= '0' && name[0] <= '9' {
		if name[1] >= '0' && name[1] <= '9' {
			if name[2] == '_' || name[2] == '-' {
				name = name[3:]
			}
		} else if name[1] == '_' || name[1] == '-' {
			name = name[2:]
		}
	}

	// ハイフンをアンダースコアに変換
	name = strings.ReplaceAll(name, "-", "_")

	return name
}

// adjustTypeForTemplate は型名をテンプレート固有に調整する
func adjustTypeForTemplate(goType string, templatePrefix string) string {
	// 名前付き型への参照を調整
	// 例: "[]ItemsItem" -> "[]UserItemsItem" (Userテンプレートの場合)
	// これは簡略化された実装。実際にはより複雑な型の処理が必要

	// スライスの場合
	if strings.HasPrefix(goType, "[]") {
		elemType := goType[2:]
		if !isBuiltinType(elemType) && !strings.Contains(elemType, ".") {
			// カスタム型の場合、プレフィックスを付ける
			return "[]" + templatePrefix + elemType
		}
	}

	// マップの場合
	if strings.HasPrefix(goType, "map[string]") {
		elemType := goType[11:] // "map[string]" の後の部分
		if !isBuiltinType(elemType) && !strings.Contains(elemType, ".") {
			return "map[string]" + templatePrefix + elemType
		}
	}

	// 単純な名前付き型の場合
	if !isBuiltinType(goType) && !strings.Contains(goType, ".") &&
		!strings.Contains(goType, "[") && !strings.HasPrefix(goType, "*") {
		return templatePrefix + goType
	}

	return goType
}

func isBuiltinType(typeName string) bool {
	builtins := []string{
		"string", "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "bool", "byte", "rune", "any",
		"time.Time", "error",
	}
	for _, b := range builtins {
		if typeName == b {
			return true
		}
	}
	return false
}