package gen

import (
	"fmt"
	"maps"
	"slices"
	"strings"

	"github.com/bellwood4486/templagen-poc/internal/scan"
	"github.com/bellwood4486/templagen-poc/internal/util"
)

type Unit struct {
	Pkg           string // 出力パッケージ名
	SourcePath    string // 埋め込むテンプレファイルのパス
	SourceLiteral string // テンプレ本文
}

func Emit(u Unit) (string, error) {
	sch, err := scan.ScanTemplate(u.SourceLiteral)
	if err != nil {
		return "", fmt.Errorf("failed to scan template: %w", err)
	}

	imports := map[string]struct{}{
		"io":            {},
		"text/template": {},
		"embed":         {},
	}

	var b strings.Builder
	fmt.Fprintf(&b, "// Code generated by templagen; DO NOT EDIT.\n")
	fmt.Fprintf(&b, "package %s\n\n", u.Pkg)

	// import セクション
	fmt.Fprintf(&b, "import (\n")
	keys := slices.Sorted(maps.Keys(imports))
	for _, k := range keys {
		if k == "embed" {
			fmt.Fprintf(&b, "\t_ %q\n", k)
		} else {
			fmt.Fprintf(&b, "\t%q\n", k)
		}
	}
	fmt.Fprintf(&b, ")\n\n")

	// テンプレ埋め込み
	fmt.Fprintf(&b, "//go:embed %s\n", u.SourcePath)
	fmt.Fprintf(&b, "var tplSource string\n\n")

	fmt.Fprintf(&b, "func Template() *template.Template {\n")
	fmt.Fprintf(&b, "\treturn template.Must(template.New(%q).Option(%q).Parse(tplSource))\n", "tpl", "missingkey=error")
	fmt.Fprintf(&b, "}\n\n")

	// 型出力(トップレベル下の struct/slice/map を再帰的に出す)
	emitTypes(&b, sch)

	// Params(トップレベル直下)
	fmt.Fprintf(&b, "type Params struct {\n")
	for name, f := range sch.Fields {
		fmt.Fprintf(&b, "\t%s %s\n", util.Export(name), goTypeOf(name, f))
	}
	fmt.Fprintf(&b, "}\n\n")

	// Render 郡
	fmt.Fprintf(&b, "func Render(w io.Writer, p Params) error { return Template().Execute(w, p) }\n\n")
	fmt.Fprintf(&b, "func RenderAny(w io.Writer, data any) error { return Template().Execute(w, data) }\n")

	return b.String(), nil
}

func emitTypes(b *strings.Builder, s scan.Schema) {
	// トップレベル子を走査し、struct(および slice/map の要素が struct)の定義を出す
	visited := map[*scan.Field]bool{}
	var walk func(prefix string, f *scan.Field)
	walk = func(prefix string, f *scan.Field) {
		if visited[f] {
			return
		}
		switch f.Kind {
		case scan.KindStruct:
			visited[f] = true
			typeName := util.Export(prefix)
			if typeName == "" {
				typeName = util.Export(f.Name)
			}
			if typeName != "Params" && len(f.Children) > 0 {
				fmt.Fprintf(b, "type %s struct {\n", typeName)
				for n, ch := range f.Children {
					fmt.Fprintf(b, "\t%s %s\n", util.Export(n), goTypeOf(n, ch))
				}
				fmt.Fprintf(b, "}\n\n")
			}
			for _, ch := range f.Children {
				walk(prefix+util.Export(f.Name), ch)
			}
		case scan.KindSlice, scan.KindMap:
			if f.Elem != nil {
				walk(prefix+util.Export(f.Name)+"Item", f.Elem)
			}
		}
	}
	for _, f := range s.Fields {
		walk("", f)
	}
}

func goTypeOf(name string, f *scan.Field) string {
	switch f.Kind {
	case scan.KindString:
		return "string"
	case scan.KindStruct:
		return util.Export(name)
	case scan.KindSlice:
		elem := "string"
		if f.Elem != nil {
			elem = goTypeOf(f.Name+"Item", f.Elem)
		}
		return "[]" + elem
	case scan.KindMap:
		val := "string"
		if f.Elem != nil {
			val = goTypeOf(f.Name+"Value", f.Elem)
		}
		return "map[string]" + val
	default:
		return "string"
	}
}

func Emit2(u Unit) (string, error) {
	imports := map[string]struct{}{
		"io":            {},
		"text/template": {},
		"embed":         {},
	}

	var b strings.Builder
	fmt.Fprintf(&b, "// Code generated by templagen; DO NOT EDIT.\n")
	fmt.Fprintf(&b, "package %s\n\n", u.Pkg)

	// import セクション
	fmt.Fprintf(&b, "import (\n")
	keys := slices.Sorted(maps.Keys(imports))
	for _, k := range keys {
		if k == "embed" {
			fmt.Fprintf(&b, "\t_ %q\n", k)
		} else {
			fmt.Fprintf(&b, "\t%q\n", k)
		}
	}
	fmt.Fprintf(&b, ")\n\n")

	// go:embed + Template + RenderAny
	fmt.Fprintf(&b, "//go:embed %s\n", u.SourcePath)
	fmt.Fprintf(&b, "var tplSource string\n\n")

	fmt.Fprintf(&b, "func Template() *template.Template {\n")
	fmt.Fprintf(&b, "\treturn template.Must(template.New(%q).Option(%q).Parse(tplSource))\n", "tpl", "missingkey=error")
	fmt.Fprintf(&b, "}\n\n")

	fmt.Fprintf(&b, "func RenderAny(w io.Writer, data any) error {\n")
	fmt.Fprintf(&b, "\treturn Template().Execute(w, data)\n")
	fmt.Fprintf(&b, "}\n")

	return b.String(), nil
}
